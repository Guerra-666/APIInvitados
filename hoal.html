<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación SJF con Líneas de Tiempo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .input-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100px;
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: filter 0.3s;
        }

        .timeline-table {
            width: 100%;
            background: white;
            border-collapse: collapse;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        .timeline-table th, .timeline-table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        .timeline {
            display: flex;
            align-items: center;
            height: 40px;
            background: #f8f9fa;
            position: relative;
        }

        .time-block {
            height: 30px;
            border-right: 1px solid #ddd;
            flex: 1;
            position: relative;
        }

        .process-bar {
            height: 70%;
            position: absolute;
            top: 15%;
            border-radius: 4px;
        }

        .time-label {
            position: absolute;
            bottom: -20px;
            font-size: 12px;
            color: #666;
        }

        .process-name {
            min-width: 80px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="input-section">
        <h1>Simulación SJF</h1>
        
        <div class="form-group">
            <input type="number" id="arrivalTime" placeholder="T. Llegada" min="0">
            <input type="number" id="burstTime" placeholder="Ráfaga CPU" min="1">
            <button onclick="addProcess()" style="background-color: #4CAF50;">Agregar Proceso</button>
        </div>
        
        <table id="inputTable">
            <thead>
                <tr>
                    <th>Proceso</th>
                    <th>T. Llegada</th>
                    <th>Ráfaga</th>
                    <th>Acción</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        
        <button onclick="runSimulation()" style="margin-top: 15px; background-color: #2196F3;">Ejecutar Simulación</button>
    </div>

    <table class="timeline-table" id="timelineResults">
        <thead>
            <tr>
                <th>Proceso</th>
                <th>Línea de Tiempo</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div class="stats" id="stats" style="margin-top: 20px; padding: 15px; background: white; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1);"></div>

    <script>
        let processes = [];
        let processCount = 1;
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD'];

        function addProcess() {
            const arrival = document.getElementById('arrivalTime').value;
            const burst = document.getElementById('burstTime').value;
            
            if (!arrival || !burst || burst < 1 || arrival < 0) {
                alert('Valores inválidos');
                return;
            }

            processes.push({
                name: `P${processCount++}`,
                arrival: parseInt(arrival),
                burst: parseInt(burst),
                color: colors[(processCount-2) % colors.length]
            });

            updateInputTable();
            document.getElementById('arrivalTime').value = '';
            document.getElementById('burstTime').value = '';
        }

        function updateInputTable() {
            const tbody = document.querySelector('#inputTable tbody');
            tbody.innerHTML = '';
            
            processes.forEach((process, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${process.name}</td>
                    <td>${process.arrival}</td>
                    <td>${process.burst}</td>
                    <td><button onclick="removeProcess(${index})" style="background-color: #f44336;">Eliminar</button></td>
                `;
                tbody.appendChild(row);
            });
        }

        function removeProcess(index) {
            processes.splice(index, 1);
            processCount--;
            updateInputTable();
        }

        function runSimulation() {
            if (processes.length === 0) {
                alert('Agregue procesos');
                return;
            }

            const executionOrder = sjfScheduling([...processes]);
            renderTimelines(executionOrder);
            showStatistics(executionOrder);
        }

        function sjfScheduling(processes) {
            processes.sort((a, b) => a.arrival - b.arrival);
            let currentTime = 0;
            const executionOrder = [];
            const pending = [...processes];

            while (pending.length > 0) {
                const available = pending.filter(p => p.arrival <= currentTime);
                if (available.length === 0) {
                    currentTime = pending[0].arrival;
                    continue;
                }

                const shortest = available.reduce((a, b) => 
                    a.burst === b.burst ? (a.arrival < b.arrival ? a : b) : (a.burst < b.burst ? a : b));
                
                shortest.start = currentTime;
                shortest.finish = currentTime + shortest.burst;
                shortest.waiting = currentTime - shortest.arrival;
                shortest.turnaround = shortest.finish - shortest.arrival;

                executionOrder.push(shortest);
                currentTime = shortest.finish;
                pending.splice(pending.indexOf(shortest), 1);
            }

            return executionOrder;
        }

        function renderTimelines(executionOrder) {
            const tbody = document.querySelector('#timelineResults tbody');
            tbody.innerHTML = '';
            const totalTime = executionOrder[executionOrder.length - 1].finish;

            executionOrder.forEach(process => {
                const row = document.createElement('tr');
                
                // Columna de nombre del proceso
                const nameCell = document.createElement('td');
                nameCell.className = 'process-name';
                nameCell.textContent = process.name;
                
                // Columna de línea de tiempo
                const timelineCell = document.createElement('td');
                const timeline = document.createElement('div');
                timeline.className = 'timeline';
                
                // Crear bloques de tiempo
                for (let i = 0; i < totalTime; i++) {
                    const timeBlock = document.createElement('div');
                    timeBlock.className = 'time-block';
                    if (i === 0) {
                        const label = document.createElement('div');
                        label.className = 'time-label';
                        label.textContent = i;
                        timeBlock.appendChild(label);
                    }
                    if (i === totalTime - 1) {
                        const label = document.createElement('div');
                        label.className = 'time-label';
                        label.textContent = totalTime;
                        timeBlock.appendChild(label);
                    }
                    timeline.appendChild(timeBlock);
                }

                // Dibujar barra del proceso
                const bar = document.createElement('div');
                bar.className = 'process-bar';
                bar.style.background = process.color;
                bar.style.left = `${(process.start / totalTime) * 100}%`;
                bar.style.width = `${(process.burst / totalTime) * 100}%`;
                
                timeline.appendChild(bar);
                timelineCell.appendChild(timeline);
                
                row.appendChild(nameCell);
                row.appendChild(timelineCell);
                tbody.appendChild(row);
            });
        }

        function showStatistics(executionOrder) {
            const stats = document.getElementById('stats');
            const totalWait = executionOrder.reduce((sum, p) => sum + p.waiting, 0);
            const totalTurnaround = executionOrder.reduce((sum, p) => sum + p.turnaround, 0);
            
            stats.innerHTML = `
                <h3>Estadísticas:</h3>
                <p>Tiempo promedio de espera: ${(totalWait / processes.length).toFixed(2)}</p>
                <p>Tiempo promedio de retorno: ${(totalTurnaround / processes.length).toFixed(2)}</p>
            `;
        }
    </script>
</body>
</html>